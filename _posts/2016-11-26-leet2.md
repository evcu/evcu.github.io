---
layout: single
title: "October Leet Code Selection "
tags: [python]
category: algorithms
excerpt: "some interesting questions I've solved and the approach I had"
---

### Leet Code Practice Selection
####  715. [Range Module](https://leetcode.com/problems/range-module/description/)
A Range Module is a module that tracks ranges of numbers. Your task is to design and implement the following interfaces in an efficient manner.

- **addRange(int left, int right)** Adds the half-open interval [left, right), tracking every real number in that interval. Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left, right) that are not already tracked.

- **queryRange(int left, int right)** Returns true if and only if every real number in the interval [left, right) is currently being tracked.

- **removeRange(int left, int right)** Stops tracking every real number currently being tracked in the interval [left, right).

**Solution**
- First idea come up to my mind was holding array of ranges sorted by its starting integer. Such that we can do a binary search on it
- However to remove the overlapping ranges and connect them, one would need some complex procedure and this could take O(n) where n is the #range-tuples (imagine adding a range including all the previous ranges)
- Then I read the post in [discussion](https://discuss.leetcode.com/topic/108032/python) and it has a very good idea of holding both the start end the end in an array. So we have an array and we are using `bisect` module to do binary search (very good module).
- We add the new range every time and then prune the everything in-between by removing them.
- All the procedures above takes O(n) where n is the #distinct integers in the ranges provided.

```python
import bisect as bi
class RangeModule(object):

    def __init__(self):
        self.range_points = [float('-inf'),float('inf')]
        self.tracking = [False,False]

    def addRange(self, left, right,track_flag=True):
        """
        :type left: int
        :type right: int
        :rtype: void
        """
        i = bi.bisect_left(self.range_points,left)
        if self.range_points[i] != left:
            self.range_points.insert(i,left)
            self.tracking.insert(i,self.tracking[i-1])

        j = bi.bisect_left(self.range_points,right)
        if self.range_points[j] != right:
            self.range_points.insert(j,right)
            self.tracking.insert(j,self.tracking[j-1])

        self.range_points[i:j] = [left]
        self.tracking[i:j] = [track_flag]

    def queryRange(self, left, right):
        """
        :type left: int
        :type right: int
        :rtype: bool
        """
        i = bi.bisect(self.range_points,left)-1
        j = bi.bisect_left(self.range_points,right)
        return all(self.tracking[i:j])


    def removeRange(self, left, right):
        """
        :type left: int
        :type right: int
        :rtype: void
        """
        self.addRange(left,right,track_flag=False)
```

#### 287. Find the Duplicate Number
Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.

Note:
- You must not modify the array (assume the array is read only).
- You must use only constant, O(1) extra space.
- Your runtime complexity should be less than O(n2).
- There is only one duplicate number in the array, but it could be repeated more than once.

**Solution**
- I provide here an nlogn solution. Note that the elements I got is in $[1,len(nums)-1]$ and I can count elements smaller than and greater than the $mid=\frac{j+i}{2}$. Having a duplicate would disturb this balance and we detect it carefully and then recurse to that side.
- I read [this](http://keithschwarz.com/interesting/code/?dir=find-duplicate), providing a really interested O(n) solution to this algorithm.


```python
def findDuplicate(nums):
        """
        :type nums: List[int]
        :rtype: int
        """

        return binSearch(nums,1,len(nums)-1)

def binSearch(arr,i,j):
    if i>=j:
        return i
    else:
        q = (j+i) // 2
        less_c = 0
        bigger_c = 0
        for e in arr:
            if i <= e <= j:
                if e <= q:
                    less_c += 1
                else:
                    bigger_c +=1
        if less_c > bigger_c:
            return binSearch(arr,i,q)
        else:
            return binSearch(arr,q+1,j)
```


```python
print findDuplicate([1,2,3,9,4,5,6,7,8,9,10])
```

    9


#### 124. Binary Tree Maximum Path Sum
Given a binary tree, find the maximum path sum.

For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.

For example:
Given the below binary tree,  
        1  
       / \  
      2   3  
Return 6.


```python
def maxPathSum(self, root):
    """
    :type root: TreeNode
    :rtype: int
    """
    self.cmax = float('-inf')
    last = self.postOrder(root)
    return self.cmax

def postOrder(self,node):
    if not node:
        return 0
    l = self.postOrder(node.left)
    r = self.postOrder(node.right)
    tot = l+r+node.val
    self.updateMax(tot)
    if l > r:
        return max(0,tot - r)
    else:
        return max(0,tot - l)

def updateMax(self,v):
    if v>self.cma`x:
        self.cmax = v

```


```python

```
